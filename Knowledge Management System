const { MongoClient } = require('mongodb');

class KnowledgeManagementSystem {
    constructor(mongodbUri) {
        this.client = new MongoClient(mongodbUri);
        this.dbName = 'gameland_knowledge';
    }

    /**
     * Initialize the connection to the MongoDB database
     */
    async initialize() {
        await this.client.connect();
        this.db = this.client.db(this.dbName);
        console.log('Connected to MongoDB');
    }

    /**
     * Store knowledge in the database
     * @param {string} category - The category of knowledge (e.g., 'designs', 'projects')
     * @param {Object} data - The data to store
     * @returns {Promise<string>} - The ID of the stored document
     */
    async storeKnowledge(category, data) {
        const collection = this.db.collection(category);
        const result = await collection.insertOne(data);
        return result.insertedId;
    }

    /**
     * Retrieve knowledge from the database
     * @param {string} category - The category of knowledge to retrieve
     * @param {Object} query - The query to filter the results
     * @returns {Promise<Array>} - The retrieved documents
     */
    async retrieveKnowledge(category, query) {
        const collection = this.db.collection(category);
        return await collection.find(query).toArray();
    }

    /**
     * Analyze project trends based on stored data
     * @returns {Promise<Object>} - The analyzed trends
     */
    async analyzeProjectTrends() {
        const projects = await this.retrieveKnowledge('projects', {});
        
        const trends = {
            totalProjects: projects.length,
            averageCompletionTime: this.calculateAverageCompletionTime(projects),
            popularGenres: this.identifyPopularGenres(projects),
            commonFeatures: this.identifyCommonFeatures(projects),
            averageTeamSize: this.calculateAverageTeamSize(projects)
        };

        return trends;
    }

    calculateAverageCompletionTime(projects) {
        const totalTime = projects.reduce((sum, project) => sum + (project.completionTime || 0), 0);
        return totalTime / projects.length;
    }

    identifyPopularGenres(projects) {
        const genreCounts = {};
        projects.forEach(project => {
            const genre = project.designDoc?.gameType || 'Unknown';
            genreCounts[genre] = (genreCounts[genre] || 0) + 1;
        });
        return Object.entries(genreCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(entry => entry[0]);
    }

    identifyCommonFeatures(projects) {
        const featureCounts = {};
        projects.forEach(project => {
            project.designDoc?.mainFeatures.forEach(feature => {
                featureCounts[feature] = (featureCounts[feature] || 0) + 1;
            });
        });
        return Object.entries(featureCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(entry => entry[0]);
    }

    calculateAverageTeamSize(projects) {
        const totalTeamSize = projects.reduce((sum, project) => sum + (project.team?.length || 0), 0);
        return totalTeamSize / projects.length;
    }
}

module.exports = KnowledgeManagementSystem;
