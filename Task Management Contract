// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

contract TaskManagement is Initializable, OwnableUpgradeable {
    struct Task {
        uint256 id;
        string description;
        address[] assignedAgents;
        TaskStatus status;
    }

    enum TaskStatus { Created, InProgress, Completed, Verified }

    mapping(uint256 => Task) public tasks;
    uint256 public taskCounter;

    event TaskCreated(uint256 indexed taskId, string description);
    event TaskAssigned(uint256 indexed taskId, address[] agents);
    event TaskStatusUpdated(uint256 indexed taskId, TaskStatus newStatus);

    function initialize() public initializer {
        __Ownable_init();
        taskCounter = 0;
    }

    function createTask(string memory _description) public onlyOwner returns (uint256) {
        uint256 taskId = taskCounter++;
        tasks[taskId] = Task({
            id: taskId,
            description: _description,
            assignedAgents: new address[](0),
            status: TaskStatus.Created
        });
        emit TaskCreated(taskId, _description);
        return taskId;
    }

    function assignTask(uint256 _taskId, address[] memory _agents) public onlyOwner {
        require(tasks[_taskId].id == _taskId, "Task does not exist");
        tasks[_taskId].assignedAgents = _agents;
        tasks[_taskId].status = TaskStatus.InProgress;
        emit TaskAssigned(_taskId, _agents);
    }

    function updateTaskStatus(uint256 _taskId, TaskStatus _newStatus) public {
        require(tasks[_taskId].id == _taskId, "Task does not exist");
        require(isAssignedAgent(msg.sender, _taskId), "Not an assigned agent");
        tasks[_taskId].status = _newStatus;
        emit TaskStatusUpdated(_taskId, _newStatus);
    }

    function verifyTask(uint256 _taskId) public onlyOwner {
        require(tasks[_taskId].id == _taskId, "Task does not exist");
        require(tasks[_taskId].status == TaskStatus.Completed, "Task not completed");
        tasks[_taskId].status = TaskStatus.Verified;
        emit TaskStatusUpdated(_taskId, TaskStatus.Verified);
    }

    function isAssignedAgent(address _agent, uint256 _taskId) internal view returns (bool) {
        for (uint i = 0; i < tasks[_taskId].assignedAgents.length; i++) {
            if (tasks[_taskId].assignedAgents[i] == _agent) {
                return true;
            }
        }
        return false;
    }
}
